# [PackageDev] target_format: plist, ext: tmLanguage
---
name: SetlX
scopeName: source.setlx
fileTypes: [stlx, setlx]
uuid: 8be6972f-85b1-4d39-b3b5-68bbfdb44d84


patterns:
- include: '#fucntions'
- include: '#values'
- include: '#keywords'

repository:
  fucntions:
    name: meta.function.setlx
    patterns:
    - include: '#procedure'
    - include: '#cached-procedure'
    - include: '#closure'
    - include: '#call'
  procedure:
    name: meta.procedure.setlx
    begin: (procedure)
    beginCaptures:
      '1': {name: storage.type.procedure.setlx}
    patterns:
    - include: '#function-signature'
    - include: '$self'
    end: \}
  cached-procedure:
    name: meta.cachedProcedure.setlx
    begin: (cachedProcedure)
    beginCaptures:
      '1': {name: storage.type.cachedProcedure.setlx}
    patterns:
    - include: '#function-signature'
    - include: '$self'
    end: \}
  closure:
    name: meta.closure.setlx
    begin: (closure)
    beginCaptures:
      '1': {name: storage.type.closure.setlx}
    patterns:
    - include: '#function-signature'
    - include: '$self'
    end: \}
  function-signature:
    begin: (\s*\()
    patterns:
    - name: keyword.control.defaultParam.setlx
      match: (\:\=)
    - include: '$self'
    end: (\)\s*\{)
  call:
    name: meta.call.setlx
    begin: ([a-z]\w*)(\s*\()
    patterns:
    - include: '$self'
    end: \)

  values:
    name: meta.value.setlx
    patterns:
    - include: '#collections'
    - include: '#lin-alg'
    - include: '#atomics'
    - name: keyword.control.setlx
      match: \_

  collections:
    patterns:
    - include: '#set'
    - include: '#list-access'
    - include: '#list'
  set:
    begin: \{
    beginCaptures:
      '0': {name: entity.enclosing.set.setlx}
    patterns:
    - include: '#general-collection'
    end: \}
    endCaptures:
      '0': {name: entity.enclosing.set.setlx}
  list-access:
    name: meta.list.access.setlx
    begin: ((\w|\])+\s*)(\[)
    patterns:
    - include: '$self'
    end: \]
  list:
    begin: \[
    beginCaptures:
      '0': {name: entity.enclosing.list.setlx}
    patterns:
    - include: '#general-collection'
    end: \]
    endCaptures:
      '0': {name: entity.enclosing.list.setlx}
  general-collection:
    name: meta.collection.setlx
    patterns:
    - include: '$self'
    - name: meta.collection.ranges.setlx
      patterns:
      - name: keyword.operator.setlx
        match: '\:'
      - include: '#iterator-chain'
    - name: meta.collection.conditions.setlx
      patterns:
      - name: keyword.operator.setlx
        match: \|
      - include: '#iterator-chain'

  lin-alg:
    patterns:
      - include: '#setl-matrix'
      - include: '#setl-vector'
  setl-matrix:
    name: meta.matrix.setlx
    begin: '<<'
    beginCaptures:
      '0':  {name: entity.enclosing.matrix.setlx}
      '1':  {name: entity.enclosing.matrix.setlx}
    patterns:
    - include: '$self'
    - include: 'meta.matrix.setlx'
    end: \>\>
    endCaptures:
      '0':  {name: entity.enclosing.matrix.setlx}
      '1':  {name: entity.enclosing.matrix.setlx}
  setl-vector:
    name: meta.vector.setlx
    begin: '<<'
    beginCaptures:
      '0':  {name: entity.enclosing.vector.setlx}
      '1':  {name: entity.enclosing.vector.setlx}
    patterns:
    - include: '#atomic-number'
    end: \>\>
    endCaptures:
      '0':  {name: entity.enclosing.vector.setlx}
      '1':  {name: entity.enclosing.vector.setlx}

  keywords:
    comment: combination of all "keyowrds" available
    patterns:
    - include: '#implication'
    - include: '#disjunction'
    - include: '#conjunction'
    - include: '#comparison-operators'
    - include: '#product-operators'
    - include: '#prefix-operators'
    - include: '#exists'
    - include: '#forall'
    - include: '#negator'
    - include: '#range-sign'
  implication:
    name: keyword.operator.implication.setlx
    match: (\=\>)
  disjunction:
    name: keyword.operator.disjunction.setlx
    match: (\|\|)
  conjunction:
    name: keyword.operator.conjunction.setlx
    match: (\&\&)
  comparison-operators:
    patterns:
    - name: keyword.operator.comparison.setlx
      match: (\=\=)
    - name: keyword.operator.comparison.setlx
      match: (\!\=)
    - name: keyword.operator.comparison.setlx
      match: (<)
    - name: keyword.operator.comparison.setlx
      match: (<\=)
    - name: keyword.operator.comparison.setlx
      match: (\>)
    - name: keyword.operator.comparison.setlx
      match: (\>\=)
    - name: keyword.operator.comparison.setlx
      match: (in)
    - name: keyword.operator.comparison.setlx
      match: (notin)
  product-operators:
    patterns:
    - name: keyword.operator.product.setlx
      match: (\*)
    - name: keyword.operator.product.setlx
      match: (/)
    - name: keyword.operator.product.setlx
      match: (\\)
    - name: keyword.operator.product.setlx
      match: (%)
    - name: keyword.operator.product.setlx
      match: (><)
  prefix-operators:
    patterns:
    - name: keyword.operator.prefix.setlx
      match: (\*\*)
    - name: keyword.operator.prefix.setlx
      match: (\+/)
    - name: keyword.operator.prefix.setlx
      match: (\*/)
    - name: keyword.operator.prefix.setlx
      match: (\#)
    - name: keyword.operator.prefix.setlx
      match: (\-)
    - name: keyword.operator.prefix.setlx
      match: (\+)
    - name: keyword.operator.prefix.setlx
      match: (\@)
  exists:
    name: keyword.operator.setlx
    match: (exists)
  forall:
    name: keyword.operator.setlx
    match: (forall)
  negator:
    name: keyword.operator.setlx
    match: (\!)
  iterator-chain:
    name: meta.iteratorchain.setlx
    patterns:
      - include: '#iterator-marker'
      - name: keyword.operator.setlx
        match: \,
  iterator-marker:        # a in x
    name: keyword.operator.setlx
    match: ( in )
  range-sign:             # ..
    name: keyword.operator.setlx
    match: (\.\.)

  atomics:
    comment: combination of all atomic values
    name: meta.atomic.setlx
    patterns:
    - include: '#atomic-languageConstant'
    - include: '#atomic-functionSymbol'
    - include: '#atomic-number'
    - include: '#atomic-double'
    - include: '#atomic-string'
    - include: '#atomic-literal'
    - include: '#atomic-comment'
  atomic-languageConstant:
    comment: combination of the three atomic, basic, language-defined constants
    patterns:
    - include: '#atomic-om'
    - include: '#atomic-true'
    - include: '#atomic-false'
  atomic-om:
    comment: atomic value, om   # undefined
    name: constant.language.setlx
    match: (om)
  atomic-true:
    comment: atomic value, true
    name: constant.language.setlx
    match: (true)
  atomic-false:
    comment: atomic value, false
    name: constant.language.setlx
    match: (false)
  atomic-functionSymbol:
    comment: combination of all three ways to defina a functionSymbol for a term
    patterns:
    - include: '#atomic-functionSymbol-capital'
    - include: '#atomic-functionSymbol-escaped'
    - include: '#atomic-functionSymbol-internal'
  atomic-functionSymbol-capital:
    comment: atomic value, functionSymbol for a term, written with an initial capital letter
    name: entity.functionSymbol.setlx
    match: ([A-Z])([a-zA-Z0-9]|_)*
  atomic-functionSymbol-escaped:
    comment: atomic value, functionSymbol for a term, written with an initial @ as escape-character
    # used internally for definitions
    name: entity.functionSymbol.setlx
    match: ((@)([a-z]))([a-zA-Z0-9]|_)*
  atomic-functionSymbol-internal:
    comment: atomic value, functionSymbol for a term, used internally for definitions
    name: entity.functionSymbol.setlx
    match: (\^)([a-zA-Z0-9]|_)*
  atomic-number:
    comment: combination of all ways to define a nuber
    patterns:
    - include: '#atomic-number-fraction'
    - include: '#atomic-double'
    - include: '#atomic-int'
  atomic-number-fraction:
    name: constant.numeric.fraction.setlx
    patterns:
    - include: '#atomic-int'
    - include: '#atomic-double'
    - name: constant.numeric.fraction.setlx
      match: (/)(?!\*|/)
  atomic-double:
    comment: atomic value, double
    name: constant.numeric.double.setlx
    match: ((0)*(\d)+)?(\.)(\d)+((e|E)(\+|\-)?(\d)+)?
  atomic-int:
    comment: atomic value, number
    name: constant.numeric.int.setlx
    match: (0)*(\d)+
  atomic-string:
    comment: atomic value, string
    name: string.quoted.setlx
    begin: (\")
    beginCaptures:
      '0': {name: string.quoted.setlx}
    patterns:
    - name: string.quoted.setlx
      match: ((?!(\\.)).)
    - name: constant.character.escape.setlx
      match: (\\.)
    end: (\")
    endCaptures:
      '0': {name: string.quoted.setlx}
  atomic-literal:
    comment: atomic value, literal  # a string whose escape characters, etc. 
                                    #   aren't interpteted
    name: string.quoted.setlx
    match: (\')(\'\'|(?!\').)*(\')
  atomic-comment:
    comment: combination of the atomic single-line- and multi-line-comments
    name: comment.setlx
    patterns:
    - include: '#atomic-comment-line'
    - include: '#atomic-comment-block'
  atomic-comment-line:
    comment: atomic value, uninterpreted, one-line-comment
    name: comment.line.setlx
    match: (//)(.)*   # sublime always only matches the current line, so no check
                      #   for a line-end / newline-char is needed
  atomic-comment-block:
    comment: atomic value, uninterpreted, multiple-line-comment
    name: comment.block.setlx
    # we want to extned the comment over multiple lines, so we must use `begin` and #   `end` instead of match
    begin: /\*
    end: \*/
...