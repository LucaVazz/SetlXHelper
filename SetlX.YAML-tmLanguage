# [PackageDev] target_format: plist, ext: tmLanguage
---
name: SetlX
scopeName: source.setlx
fileTypes: [stlx, setlx]
uuid: 8be6972f-85b1-4d39-b3b5-68bbfdb44d84


patterns:
- comment: setlMatrix
  name: meta.matrix.setlx
  begin: '<<'
  beginCaptures:
    '0':  {name: entity.enclosing.matrix.setlx}
    '1':  {name: entity.enclosing.matrix.setlx}
  patterns:
  - include: '$self'
  - include: 'meta.matrix.setlx'
  end: \>\>
  endCaptures:
    '0':  {name: entity.enclosing.matrix.setlx}
    '1':  {name: entity.enclosing.matrix.setlx}
- comment: setlVector
  name: meta.vector.setlx
  begin: '<<'
  beginCaptures:
    '0':  {name: entity.enclosing.vector.setlx}
    '1':  {name: entity.enclosing.vector.setlx}
  patterns:
  - include: '#atomic-number'
  end: \>\>
  endCaptures:
    '0':  {name: entity.enclosing.vector.setlx}
    '1':  {name: entity.enclosing.vector.setlx}

- include: '#atomics'


repository:
  atomics:
    comment: combination of all atomic values
    name: constant.language.setlx.atomic
    patterns:
    - include: '#atomic-languageConstant'
    - include: '#atomic-functionSymbol'
    - include: '#atomic-number'
    - include: '#atomic-double'
    - include: '#atomic-range-sign'
    - include: '#atomic-string'
    - include: '#atomic-literal'
    - include: '#atomic-comment'
  atomic-languageConstant:
    comment: combination of the three atomic, basic, language-defined constants
    patterns:
    - include: '#atomic-om'
    - include: '#atomic-true'
    - include: '#atomic-false'
  atomic-om:
    comment: atomic value, om   # undefined
    name: constant.language.setlx
    match: (om)
  atomic-true:
    comment: atomic value, true
    name: constant.language.setlx
    match: (true)
  atomic-false:
    comment: atomic value, false
    name: constant.language.setlx
    match: (false)
  atomic-functionSymbol:
    comment: combination of all three ways to defina a functionSymbol for a term
    patterns:
    - include: '#atomic-functionSymbol-capital'
    - include: '#atomic-functionSymbol-escaped'
    - include: '#atomic-functionSymbol-internal'
  atomic-functionSymbol-capital:
    comment: atomic value, functionSymbol for a term, written with an initial capital letter
    name: entity.functionSymbol.setlx
    match: ([A-Z])([a-zA-Z0-9]|_)*
  atomic-functionSymbol-escaped:
    comment: atomic value, functionSymbol for a term, written with an initial @ as escape-character
    # used internally for definitions
    name: entity.functionSymbol.setlx
    match: ((@)([a-z]))([a-zA-Z0-9]|_)*
  atomic-functionSymbol-internal:
    comment: atomic value, functionSymbol for a term, used internally for definitions
    name: entity.functionSymbol.setlx
    match: (\^)([a-zA-Z0-9]|_)*
  atomic-number:
    comment: combination of all ways to define a nuber
    patterns:
    - include: '#atomic-number-fraction'
    - include: '#atomic-double'
    - include: '#atomic-int'
  atomic-number-fraction:
    name: constant.numeric.fraction.setlx
    patterns:
    - include: '#atomic-int'
    - include: '#atomic-double'
    - name: keyword.operator.setlx
      match: (/)(?!\*|/)
  atomic-double:
    comment: atomic value, double
    name: constant.numeric.double.setlx
    match: (\-|\+)?((0)*(\d)+)?(\.)(\d)+((e|E)(\+|\-)?(\d)+)?
  atomic-int:
    comment: atomic value, number
    name: constant.numeric.int.setlx
    match: (\-|\+)?(0)*(\d)+
  atomic-range-sign:
    comment: atomic value, range sign   # ..
    name: keyword.operator.setlx
    match: (\.\.)
  atomic-string:
    comment: atomic value, string
    name: string.quoted.setlx
    match: (\")((?!\")(\\.)*.)*(\")
  atomic-literal:
    comment: atomic value, literal  # a string whose escape characters, etc. 
                                    #   aren't interpteted
    name: string.quoted.setlx
    match: (\')(\'\'|(?!\').)*(\')
  atomic-comment:
    comment: combination of the atomic single-line- and multi-line-comments
    name: comment.setlx
    patterns:
    - include: '#atomic-comment-line'
    - include: '#atomic-comment-block'
  atomic-comment-line:
    comment: atomic value, uninterpreted, one-line-comment
    name: comment.line.setlx
    match: (//)(.)*   # sublime always only matches the current line, so no check
                      #   for a line-end / newline-char is needed
  atomic-comment-block:
    comment: atomic value, uninterpreted, multiple-line-comment
    name: comment.block.setlx
    # we want to extned the comment over multiple lines, so we must use `begin` and #   `end` instead of match
    begin: /\*
    end: \*/
...